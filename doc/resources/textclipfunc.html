<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html>
<head>
<title>MHonArc Resources: TEXTCLIPFUNC</title>
</head>
<body>
<!--x-rc-nav-->
<table border=0><tr valign="top">
<td align="left" width="50%">[Prev:&nbsp;<a href="tcontend.html">TCONTEND</a>]</td><td><nobr>[<a href="../resources.html#textclipfunc">Resources</a>][<a href="../mhonarc.html">TOC</a>]</nobr></td><td align="right" width="50%">[Next:&nbsp;<a href="tfirstpglink.html">TFIRSTPGLINK</a>]</td></tr></table>
<!--/x-rc-nav-->
<hr>
<h1>TEXTCLIPFUNC</h1>

<!-- *************************************************************** -->
<hr>
<h2>Syntax</h2>

<dl>

<dt><strong>Envariable</strong></dt>
<dd><p>N/A
</p>
</dd>

<dt><strong>Element</strong></dt>
<dd><p>
<code>&lt;TEXTCLIPFUNC&gt;</code><br>
<var>function_name</var>;<var>source_file</var><br>
<code>&lt;/TEXTCLIPFUNC&gt;</code><br>
</p>
</dd>

<dt><strong>Command-line Option</strong></dt>
<dd><p>N/A
</p>
</dd>

</dl>

<!-- *************************************************************** -->
<hr>
<h2>Description</h2>

<p>TEXTCLIPFUNC defines the the Perl function to invoke when
MHonArc clips text.  For example, the function specified would
be invoked when a length specifier is used for a
<a href="../rcvars.html">resource variable</a>, e.g.
<tt>$SUBJECTNA:72$</tt>.
</p>

<p>The syntax for TEXTCLIPFUNC is as follows:
</p>

<pre>
<var>routine-name</var>;<var>file-of-routine</var></pre>

<p>The definition of each semi-colon-separated value is as follows:
</p>

<dl>
<dt><var>routine-name</var></dt>
    <dd><p>The actual routine name of the filter. The name
    should be fully qualified by the package it is defined in
    (e.g. "<code>mypackage::filter</code>").
    </p>
    <dd>
<dt><var>file-of-routine</var></dt>
    <dd><p>The name of the file that defines
    <var>routine-name</var>. If the file is not a full
    pathname, MHonArc finds the file by looking in the
    standard include paths of Perl, and the paths specified by the
    <A HREF="perlinc.html">PERLINC</A>
    resource. 
    </p>
    <p><var>file-of-routine</var> can be left blank if it is
    known that <var>routine-name</var> will already be loaded, as
    is the case for the default value for this resource since the
    routine is an internal MHonArc function.
    </p>
    </dd>
</dl>

<h3><a name="writing">Writing a Clipping Function</a></h3>

<p>If you want to write your own function, you need to know the Perl
programming language. The following information assumes you know Perl.
</p>

<h4>Function Interface</h4>

<P>MHonArc interfaces with text clipping function by calling the routine
with a specific set of arguments. The prototype of the interface
routine is as follows: </P>

<pre>
sub <var>clip</var> {
    my(<b>$text</b>, <b>$clip_length</b>, <b>$is_html</b>, <b>$has_tags</b>) = @_;
    <var># code here
}
</pre>

<h5>Parameter Descriptions</h5>

<table cellspacing=1 border=0 cellpadding=4>

<tr valign=top>
<td><strong><code>$text</code></strong></td>
<td><p>The text to be clipped.
</p>
<p><b>NOTE:</b> Since Perl allows one to modify the data passed into
it, the first argument should <strong>NOT</strong> be modified.  If
you copy arguments from <tt>@_</tt> as shown above, then you will be
okay since the <tt>my</tt> operation creates a copy of the arguments
in <tt>@_</tt>.
</p>
</td>
</tr>

<tr valign=top>
<td><strong><code>$clip_length</code></strong></td>
<td><p>The number of characters <code>$text</code> should be clipped to.
</p>
</td>
</tr>

<tr valign=top>
<td><strong><code>$is_html</code></strong></td>
<td><p>The text may contain entity references, e.g. "<tt>&amp;amp;</tt>".
Entity references should be considered a single character when
clipping <code>$text</code>.
</p>
</td>
</tr>

<tr valign=top>
<td><strong><code>$has_tags</code></strong></td>
<td><p>The text may contain HTML tags, and the tags should be stripped
from <code>$text</code> when generating the clip string.  For example,
if <code>$text</code> equals "<tt>&lt;b&gt;MHonArc&lt;/b&gt;</tt>" and
<code>$clip_length</code> equals 2, then the return value of the
function should be "<tt>MH</tt>".
</p>
    <table border=0 cellpadding=4>
    <tr valign=top>
    <td><strong>NOTE</strong></td>
    <td><p>The <code>$has_tags</code> argument is currently
    not used within MHonArc, but it will likely be used in a future release.
    </p>
    </td>
    </tr>
    </table>
</td>
</tr>

</table>

<h5>Return Value</h5>

<p>The return value should be the clipped version of <code>$text</code>.
</p>

<H4>Writing Tips</h4>

<ul>
<li><p>Qualify your filter in its own package. This eliminates possible 
variable/routine conflicts with MHonArc.
</p>

<li><p>Make sure your Perl source file ends with a true statement
(like "<code>1;</code>").  MHonArc just performs a
<strong><code>require</code></strong>
on the file, and if the file does not return
true, MHonArc will revert to the default value for TEXTCLIPFUNC.
</p>

<li><p>Test your function before production use.
</p>

</ul>

<!-- *************************************************************** -->
<hr>
<h2>Default Setting</h2>

<pre>
mhonarc::clip_text;
</pre>

<!-- *************************************************************** -->
<hr>
<h2>Resource Variables</h2>

<p>N/A
</p>

<!-- *************************************************************** -->
<hr>
<h2>Examples</h2>

<p>The <a href="../rcfileexs/utf-8.mrc.html">Unicode</a> example
resource file sets TEXTCLIPFUNC to a routine that understands UTF-8
text.
</p>

<p>The following is the implementation (as of this writing) of
MHonArc's default clipping function:
</p>

<pre>
sub clip_text {
    my $str      = \shift;  # Prevent unnecessary copy.
    my $len      = shift;   # Clip length
    my $is_html  = shift;   # If entity references should be considered
    my $has_tags = shift;   # If html tags should be stripped

    if (!$is_html) {
      return substr($$str, 0, $len);
    }

    my $text = "";
    my $subtext = "";
    my $html_len = length($$str);
    my($pos, $sublen, $erlen, $real_len);
    my $er_len = 0;
    
    for ( $pos=0, $sublen=$len; $pos &lt; $html_len; ) {
	$subtext = substr($$str, $pos, $sublen);
	$pos += $sublen;

	# strip tags
	if ($has_tags) {
	    $subtext =~ s/\A[^&lt;]*&gt;//; # clipped tag
	    $subtext =~ s/&lt;[^&gt;]*&gt;//g;
	    $subtext =~ s/&lt;[^&gt;]*\Z//; # clipped tag
	}

	# check for clipped entity reference
	if (($pos &lt; $html_len) &amp;&amp; ($subtext =~ /\&amp;[^;]*\Z/)) {
	    my $semi = index($$str, ';', $pos);
	    if ($semi &lt; 0) {
		# malformed entity reference
		$subtext .= substr($$str, $pos);
		$pos = $html_len;
	    } else {
		$subtext .= substr($$str, $pos, $semi-$pos+1)
		    if $semi &gt; $pos;
		$pos = $semi+1;
	    }
	}

	# compute entity reference lengths to determine "real" character
	# count and not raw character count.
	while ($subtext =~ /(\&amp;[^;]+);/g) {
	    $er_len += length($1);
	}

	$text .= $subtext;

	# done if we have enough
	$real_len = length($text)-$er_len;
	if ($real_len &gt;= $len) {
	    last;
	}
	$sublen = $len - (length($text)-$er_len);
    }
    $text;
}
</pre>

<!-- *************************************************************** -->
<hr>
<h2>Version</h2>

<p>2.5.10
</p>

<!-- *************************************************************** -->
<hr>
<h2>See Also</h2>

<p><a href="../rcvars.html"><cite>Resource Variables</cite></a>
</p>

<!-- *************************************************************** -->
<hr>
<!--x-rc-nav-->
<table border=0><tr valign="top">
<td align="left" width="50%">[Prev:&nbsp;<a href="tcontend.html">TCONTEND</a>]</td><td><nobr>[<a href="../resources.html#textclipfunc">Resources</a>][<a href="../mhonarc.html">TOC</a>]</nobr></td><td align="right" width="50%">[Next:&nbsp;<a href="tfirstpglink.html">TFIRSTPGLINK</a>]</td></tr></table>
<!--/x-rc-nav-->
<hr>
<address>
$Date: 2002/08/04 03:58:27 $<br>
<img align="top" src="../monicon.png" alt="">
<a href="http://www.mhonarc.org/"><strong>MHonArc</strong></a><br>
Copyright &#169; 2002, <a href="http://www.earlhood.com/"
>Earl Hood</a>, <a href="mailto:mhonarc@mhonarc.org"
>mhonarc@mhonarc.org</a><br>
</address>

</body>
</html>
